// automatically generated by arduino-cmake
#line 1 "/Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/MasterSketch.ino"
#include "LoadCell_functions.h"
#include "Encoder_functions.h"
#include "Motor_functions.h"
#include "FSM.h"
#include "Button.h"
#include "Thresholds.h"
#include "Sensor_Interrupt.h"
#include "Inner_FSMs.h"
//#include "Accelerometer_functions.h"


//#define DEBUG_CONFIG // comment this line out to run full system
//#define CALIBRATION_CONFIG_LC // comment this line out to run full system
//#define CALIBRATION_CONFIG_ENCODER // comment this line out to run full system
//#define EXTEND_LEG // this is used to extend the leg upon startup


#line 20 "/Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/cmake-build-debug/MasterSketch_MasterSketch.ino.cpp"
#include "Arduino.h"

//=== START Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Accelerometer_functions.ino
 void Init_Accelerometer() ;
 void Init_Accelerometer() ;
 int getX() ;
 int getX() ;
 int getY() ;
 int getY() ;
 int getZ() ;
 int getZ() ;
 int acc_to_ang(int acc) ;
 int acc_to_ang(int acc) ;
//=== END Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Accelerometer_functions.ino

//=== START Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Button.ino
 void Init_Button() ;
 void Init_Button() ;
//=== END Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Button.ino

//=== START Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Encoder_functions.ino
 void Init_Encoders() ;
 void Init_Encoders() ;
 uint16_t getPositionSPI(uint8_t encoder, uint8_t resolution) ;
 uint16_t getPositionSPI(uint8_t encoder, uint8_t resolution) ;
 uint8_t spiWriteRead(uint8_t sendByte, uint8_t encoder, uint8_t releaseLine) ;
 uint8_t spiWriteRead(uint8_t sendByte, uint8_t encoder, uint8_t releaseLine) ;
 void setCSLine (uint8_t encoder, uint8_t csLine) ;
 void setCSLine (uint8_t encoder, uint8_t csLine) ;
 void setZeroSPI(uint8_t encoder) ;
 void setZeroSPI(uint8_t encoder) ;
 void resetAMT22(uint8_t encoder) ;
 void resetAMT22(uint8_t encoder) ;
 int bitToDegrees(int bitCount) ;
 int bitToDegrees(int bitCount) ;
//=== END Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Encoder_functions.ino

//=== START Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/FSM.ino
 void MasterFSM(MasterFSMState init_state) ;
 void MasterFSM(MasterFSMState init_state) ;
//=== END Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/FSM.ino

//=== START Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/HX711.ino
 uint8_t shiftInSlow(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) ;
 uint8_t shiftInSlow(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) ;
//=== END Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/HX711.ino

//=== START Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Inner_FSMs.ino
 void Sit() ;
 void Sit() ;
 void Stand() ;
 void Stand() ;
 void Free_Swing() ;
 void Free_Swing() ;
 int GaitFSM(GaitFSMState init_state) ;
 int GaitFSM(GaitFSMState init_state) ;
 void Bend_Knee() ;
 void Bend_Knee() ;
 void Retract_Knee() ;
 void Retract_Knee() ;
 void Extend_Knee() ;
 void Extend_Knee() ;
//=== END Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Inner_FSMs.ino

//=== START Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/LoadCell_functions.ino
 void Init_LC() ;
 void Init_LC() ;
 void Calibrate_LC(HX711 loadcell) ;
 void Calibrate_LC(HX711 loadcell) ;
 int Read_LC1() ;
 int Read_LC1() ;
 int Read_LC2() ;
 int Read_LC2() ;
 int Read_LC3() ;
 int Read_LC3() ;
 int Read_LC4() ;
 int Read_LC4() ;
//=== END Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/LoadCell_functions.ino

//=== START Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Motor_functions.ino
 void Init_Motors() ;
 void Init_Motors() ;
 int rotate(int dir, int angle) ;
 int rotate(int dir, int angle) ;
 int rot(int angle) ;
 int rot(int angle) ;
//=== END Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Motor_functions.ino

//=== START Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Sensor_Interrupt.ino
 void Init_Interrupt() ;
 void Init_Interrupt() ;
 void Read_Sensors() ;
 void Read_Sensors() ;
//=== END Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Sensor_Interrupt.ino

//=== START Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/MasterSketch.ino
 void setup() ;
 void setup() ;
 void loop() ;
 void loop() ;
//=== END Forward: /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/MasterSketch.ino
#line 16 "/Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/MasterSketch.ino"


void setup() {
    // Initialize
    Init_Encoders();
    Init_LC();
//  Init_Motors();
//  Init_Button();
    Init_Interrupt();

#ifdef DEBUG_CONFIG

#endif

#ifdef CALIBRATION_CONFIG_LC
    Calibrate_LC(loadcell1);
    Calibrate_LC(loadcell2);
    Calibrate_LC(loadcell3);
    Calibrate_LC(loadcell4);
#endif

#ifdef CALIBRATION_CONFIG_ENCODER
    // For calibrating encoders, we need to first
    // make sure that they are initialized at full extension
    // Then we set the encoders to 0
    setZeroSPI(ENC_0);
    setZeroSPI(ENC_1);
#endif

#ifdef EXTEND_LEG

#endif

}

void loop() {
//  Serial.print("LC: ");
//  Serial.print(loadcell1.read()/1000);
//  Serial.println();
//  Serial.print("Encoder 0: ");
//  Serial.print(getPositionSPI(ENC_0, RES14), DEC);
//  Serial.println();
//  Serial.print("Encoder 1: ");
//  Serial.print(getPositionSPI(ENC_1, RES14), DEC);
//  Serial.println();
//  MasterFSM(curr_state);
    Serial.println(encKnee);
    rot(100);
    Serial.println(curr_speed);
}

//=== START : /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Accelerometer_functions.ino
#line 1 "/Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Accelerometer_functions.ino"
#include <Arduino.h>
#include <Adafruit_MMA8451.h>
#include "Accelerometer_functions.h"

void Init_Accelerometer() {
  if (! mma.begin()) {
    Serial.println("Couldnt start");
    while (1);
  }
  if (mma.getRange() != 1) {
    mma.setRange(MMA8451_RANGE_2_G);
  }
}

int getX() {
  mma.getEvent(&event);
  return event.acceleration.x;
}

int getY() {
  mma.getEvent(&event);
  return event.acceleration.y;
}

int getZ() {
  mma.getEvent(&event);
  return event.acceleration.z;
}

/**
 * converts given acceleration to an angle that can be
 * used for calculating angle direction for gravity
 */
int acc_to_ang(int acc) {
  return 0;
}

//=== END : /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Accelerometer_functions.ino

//=== START : /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Button.ino
#line 1 "/Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Button.ino"
#include <Arduino.h>
#include "Button.h"

/**
 * Initializes button for Locked state
 */
void Init_Button() {
  pinMode(LOCKED_BUTTON, INPUT);
}

//=== END : /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Button.ino

//=== START : /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Encoder_functions.ino
#line 1 "/Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Encoder_functions.ino"
#include "Encoder_functions.h"

/*
 * Code to initialize SPI for the encoders
 */
void Init_Encoders()
{
  //Set the modes for the SPI IO
  pinMode(SPI_SCLK, OUTPUT);
  pinMode(SPI_MOSI, OUTPUT);
  pinMode(SPI_MISO, INPUT);
  pinMode(ENC_0, OUTPUT);
  pinMode(ENC_1, OUTPUT);

  //Initialize the UART serial connection for debugging
  Serial.begin(BAUDRATE_ENCODER);

  //Get the CS line high which is the default inactive state
  digitalWrite(ENC_0, HIGH);
  digitalWrite(ENC_1, HIGH);
  SPI.setClockDivider(SPI_CLOCK_DIV32);    // 500 kHz
  SPI.begin();
}

/*
   This function gets the absolute position from the AMT22 encoder using the SPI bus. The AMT22 position includes 2 checkbits to use
   for position verification. Both 12-bit and 14-bit encoders transfer position via two bytes, giving 16-bits regardless of resolution.
   For 12-bit encoders the position is left-shifted two bits, leaving the right two bits as zeros. This gives the impression that the encoder
   is actually sending 14-bits, when it is actually sending 12-bit values, where every number is multiplied by 4.
   This function takes the pin number of the desired device as an input
   This funciton expects res12 or res14 to properly format position responses.
   Error values are returned as 0xFFFF
*/
uint16_t getPositionSPI(uint8_t encoder, uint8_t resolution)
{
  uint16_t currentPosition;       //16-bit response from encoder
  bool binaryArray[16];           //after receiving the position we will populate this array and use it for calculating the checksum

  //get first byte which is the high byte, shift it 8 bits. don't release line for the first byte
  currentPosition = spiWriteRead(AMT22_NOP, encoder, LOW) << 8;

  //this is the time required between bytes as specified in the datasheet.
  //We will implement that time delay here, however the arduino is not the fastest device so the delay
  //is likely inherantly there already
  delayMicroseconds(3);

  //OR the low byte with the currentPosition variable. release line after second byte
  currentPosition |= spiWriteRead(AMT22_NOP, encoder, HIGH);

  //run through the 16 bits of position and put each bit into a slot in the array so we can do the checksum calculation
  for (int i = 0; i < 16; i++) binaryArray[i] = (0x01) & (currentPosition >> (i));

  //using the equation on the datasheet we can calculate the checksums and then make sure they match what the encoder sent
  if ((binaryArray[15] == !(binaryArray[13] ^ binaryArray[11] ^ binaryArray[9] ^ binaryArray[7] ^ binaryArray[5] ^ binaryArray[3] ^ binaryArray[1]))
      && (binaryArray[14] == !(binaryArray[12] ^ binaryArray[10] ^ binaryArray[8] ^ binaryArray[6] ^ binaryArray[4] ^ binaryArray[2] ^ binaryArray[0])))
  {
    //we got back a good position, so just mask away the checkbits
    currentPosition &= 0x3FFF;
  }
  else
  {
    currentPosition = 0xFFFF; //bad position
  }

  //If the resolution is 12-bits, and wasn't 0xFFFF, then shift position, otherwise do nothing
  if ((resolution == RES12) && (currentPosition != 0xFFFF)) currentPosition = currentPosition >> 2;

  return currentPosition;
}

/*
   This function does the SPI transfer. sendByte is the byte to transmit.
   Use releaseLine to let the spiWriteRead function know if it should release
   the chip select line after transfer.
   This function takes the pin number of the desired device as an input
   The received data is returned.
*/
uint8_t spiWriteRead(uint8_t sendByte, uint8_t encoder, uint8_t releaseLine)
{
  //holder for the received over SPI
  uint8_t data;

  //set cs low, cs may already be low but there's no issue calling it again except for extra time
  setCSLine(encoder , LOW);

  //There is a minimum time requirement after CS goes low before data can be clocked out of the encoder.
  //We will implement that time delay here, however the arduino is not the fastest device so the delay
  //is likely inherantly there already
  delayMicroseconds(3);

  //send the command
  data = SPI.transfer(sendByte);
  delayMicroseconds(3); //There is also a minimum time after clocking that CS should remain asserted before we release it
  setCSLine(encoder, releaseLine); //if releaseLine is high set it high else it stays low

  return data;
}

/*
   This function sets the state of the SPI line. It isn't necessary but makes the code more readable than having digitalWrite everywhere
   This function takes the pin number of the desired device as an input
*/
void setCSLine (uint8_t encoder, uint8_t csLine)
{
  digitalWrite(encoder, csLine);
}

/*
   The AMT22 bus allows for extended commands. The first byte is 0x00 like a normal position transfer, but the
   second byte is the command.
   This function takes the pin number of the desired device as an input
*/
void setZeroSPI(uint8_t encoder)
{
  spiWriteRead(AMT22_NOP, encoder, false);

  //this is the time required between bytes as specified in the datasheet.
  //We will implement that time delay here, however the arduino is not the fastest device so the delay
  //is likely inherantly there already
  delayMicroseconds(3);

  spiWriteRead(AMT22_ZERO, encoder, true);
  delay(250); //250 second delay to allow the encoder to reset
}

/*
   The AMT22 bus allows for extended commands. The first byte is 0x00 like a normal position transfer, but the
   second byte is the command.
   This function takes the pin number of the desired device as an input
*/
void resetAMT22(uint8_t encoder)
{
  spiWriteRead(AMT22_NOP, encoder, false);

  //this is the time required between bytes as specified in the datasheet.
  //We will implement that time delay here, however the arduino is not the fastest device so the delay
  //is likely inherantly there already
  delayMicroseconds(3);

  spiWriteRead(AMT22_RESET, encoder, true);

  delay(250); //250 second delay to allow the encoder to start back up
}

int bitToDegrees(int bitCount) {
  int deg = map(bitCount, 0, ENC_MAX, 0, 359);
  return deg;
}

//=== END : /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Encoder_functions.ino

//=== START : /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/FSM.ino
#line 1 "/Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/FSM.ino"
#include "FSM.h"
#include "Button.h"
#include "LoadCell_functions.h"
#include "Thresholds.h"
#include "Encoder_functions.h"

// boolean for whether the leg has fully retracted for RETRACTION State
//boolean retracted = false;

/**
 * v1.0 of FSM Created on 01/21/20
 * FSM contains the entire FSM of the Leg
 * @param init_state - the initial state that the FSM starts in; should be LOCKED
 * @return exit code - should only happen if fails (returns a 0 in this case)
 */
void MasterFSM(MasterFSMState init_state) {
  MasterFSMState current_state = init_state;
  switch(current_state) {
    case LOCKED:
      if (button_state == 0) {
        current_state = MIDSTANCE;
      }
      break;
    case MIDSTANCE:
      if (button_state == 1) {
        current_state = LOCKED;
      } else if (lcBack > MIDSTANCE_SIT_TH) {
        current_state = SIT;
      } else if (lcFront > MIDSTANCE_GAIT_TH) {
        current_state = GAIT;
      } else if (lcFront < ZERO_ERROR_LC && lcBack < ZERO_ERROR_LC && lcRight < ZERO_ERROR_LC && lcLeft < ZERO_ERROR_LC) {
        current_state = RETRACTION;
      }
      break;
    case SIT:
      if (lcBack > SIT_STAND_TH) {
        current_state = STAND;
      } else {
        // Sit();
      }
      break;
    case STAND:
      if ((encKnee +  ENC_MAX / 2) % ENC_MAX - ENC_MAX / 2 < ZERO_ERROR_ENC && abs(lcFront - lcBack) < ZERO_ERROR_LC) {
        current_state = MIDSTANCE;
      } else {
        // Stand();
      }
      break;
    case GAIT:
      if (lcBack > GAIT_H_STRIKE_TH) {
        current_state = H_STRIKE;
      } else {
        // Gait_Motion();
      }
      break;
    case H_STRIKE:
      if ((encKnee +  ENC_MAX / 2) % ENC_MAX - ENC_MAX / 2 < ZERO_ERROR_ENC && abs(lcFront - lcBack) < ZERO_ERROR_LC) {
        current_state = MIDSTANCE;
      } else {
        // Straighten_Leg();
      }
      break;
    case FULL_EXT:
      if ((encKnee +  ENC_MAX / 2) % ENC_MAX - ENC_MAX / 2 < ZERO_ERROR_ENC && abs(lcFront - lcBack) < ZERO_ERROR_LC) {
        current_state = MIDSTANCE;
      }
      break;
    case RETRACTION:
      if (!retracted) {
        // Retract();
      } else {
        // Free_Swing();
      }
      if (lcFront > RETRACTION_FULL_EXT_LCFRONT_TH && lcBack > RETRACTION_FULL_EXT_LCBACK_TH
            && lcLeft > RETRACTION_FULL_EXT_LCLEFT_TH && lcRight > RETRACTION_FULL_EXT_LCRIGHT_TH) {
        current_state = FULL_EXT;
        retracted = false;
      } else if (lcBack > RETRACTION_H_STRIKE_LCBACK_TH && lcBack - lcFront > RETRACTION_H_STRIKE_LCBACKFRONT_TH
            && (encKnee +  ENC_MAX / 2) % ENC_MAX - ENC_MAX / 2 < ZERO_ERROR_ENC) {
        current_state = H_STRIKE;
        retracted = false;
      }
      
      break;
    default:
      // Do Nothing here
      break;
  }
  curr_state = current_state;
}

//=== END : /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/FSM.ino

//=== START : /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/HX711.ino
#line 1 "/Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/HX711.ino"
/**
 *
 * HX711 library for Arduino
 * https://github.com/bogde/HX711
 *
 * MIT License
 * (c) 2018 Bogdan Necula
 *
**/
#include <Arduino.h>
#include "HX711.h"

// TEENSYDUINO has a port of Dean Camera's ATOMIC_BLOCK macros for AVR to ARM Cortex M3.
#define HAS_ATOMIC_BLOCK (defined(ARDUINO_ARCH_AVR) || defined(TEENSYDUINO))

// Whether we are running on either the ESP8266 or the ESP32.
#define ARCH_ESPRESSIF (defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32))

// Whether we are actually running on FreeRTOS.
#define IS_FREE_RTOS defined(ARDUINO_ARCH_ESP32)

// Define macro designating whether we're running on a reasonable
// fast CPU and so should slow down sampling from GPIO.
#define FAST_CPU \
    ( \
    ARCH_ESPRESSIF || \
    defined(ARDUINO_ARCH_SAM)     || defined(ARDUINO_ARCH_SAMD) || \
    defined(ARDUINO_ARCH_STM32)   || defined(TEENSYDUINO) \
    )

#if HAS_ATOMIC_BLOCK
// Acquire AVR-specific ATOMIC_BLOCK(ATOMIC_RESTORESTATE) macro.
#include <util/atomic.h>
#endif

#if FAST_CPU
// Make shiftIn() be aware of clockspeed for
// faster CPUs like ESP32, Teensy 3.x and friends.
// See also:
// - https://github.com/bogde/HX711/issues/75
// - https://github.com/arduino/Arduino/issues/6561
// - https://community.hiveeyes.org/t/using-bogdans-canonical-hx711-library-on-the-esp32/539
uint8_t shiftInSlow(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
    uint8_t value = 0;
    uint8_t i;

    for(i = 0; i < 8; ++i) {
        digitalWrite(clockPin, HIGH);
        delayMicroseconds(1);
        if(bitOrder == LSBFIRST)
            value |= digitalRead(dataPin) << i;
        else
            value |= digitalRead(dataPin) << (7 - i);
        digitalWrite(clockPin, LOW);
        delayMicroseconds(1);
    }
    return value;
}
#define SHIFTIN_WITH_SPEED_SUPPORT(data,clock,order) shiftInSlow(data,clock,order)
#else
#define SHIFTIN_WITH_SPEED_SUPPORT(data,clock,order) shiftIn(data,clock,order)
#endif


HX711::HX711() {
}

HX711::~HX711() {
}

void HX711::begin(byte dout, byte pd_sck, byte gain) {
	PD_SCK = pd_sck;
	DOUT = dout;

	pinMode(PD_SCK, OUTPUT);
	pinMode(DOUT, INPUT);

	set_gain(gain);
}

bool HX711::is_ready() {
	return digitalRead(DOUT) == LOW;
}

void HX711::set_gain(byte gain) {
	switch (gain) {
		case 128:		// channel A, gain factor 128
			GAIN = 1;
			break;
		case 64:		// channel A, gain factor 64
			GAIN = 3;
			break;
		case 32:		// channel B, gain factor 32
			GAIN = 2;
			break;
	}

	digitalWrite(PD_SCK, LOW);
	read();
}

long HX711::read() {

	// Wait for the chip to become ready.
	wait_ready();

	// Define structures for reading data into.
	unsigned long value = 0;
	uint8_t data[3] = { 0 };
	uint8_t filler = 0x00;

	// Protect the read sequence from system interrupts.  If an interrupt occurs during
	// the time the PD_SCK signal is high it will stretch the length of the clock pulse.
	// If the total pulse time exceeds 60 uSec this will cause the HX711 to enter
	// power down mode during the middle of the read sequence.  While the device will
	// wake up when PD_SCK goes low again, the reset starts a new conversion cycle which
	// forces DOUT high until that cycle is completed.
	//
	// The result is that all subsequent bits read by shiftIn() will read back as 1,
	// corrupting the value returned by read().  The ATOMIC_BLOCK macro disables
	// interrupts during the sequence and then restores the interrupt mask to its previous
	// state after the sequence completes, insuring that the entire read-and-gain-set
	// sequence is not interrupted.  The macro has a few minor advantages over bracketing
	// the sequence between `noInterrupts()` and `interrupts()` calls.
	#if HAS_ATOMIC_BLOCK
	ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {

	#elif IS_FREE_RTOS
	// Begin of critical section.
	// Critical sections are used as a valid protection method
	// against simultaneous access in vanilla FreeRTOS.
	// Disable the scheduler and call portDISABLE_INTERRUPTS. This prevents
	// context switches and servicing of ISRs during a critical section.
	portMUX_TYPE mux = portMUX_INITIALIZER_UNLOCKED;
	portENTER_CRITICAL(&mux);

	#else
	// Disable interrupts.
	noInterrupts();
	#endif

	// Pulse the clock pin 24 times to read the data.
	data[2] = SHIFTIN_WITH_SPEED_SUPPORT(DOUT, PD_SCK, MSBFIRST);
	data[1] = SHIFTIN_WITH_SPEED_SUPPORT(DOUT, PD_SCK, MSBFIRST);
	data[0] = SHIFTIN_WITH_SPEED_SUPPORT(DOUT, PD_SCK, MSBFIRST);

	// Set the channel and the gain factor for the next reading using the clock pin.
	for (unsigned int i = 0; i < GAIN; i++) {
		digitalWrite(PD_SCK, HIGH);
		#if ARCH_ESPRESSIF
		delayMicroseconds(1);
		#endif
		digitalWrite(PD_SCK, LOW);
		#if ARCH_ESPRESSIF
		delayMicroseconds(1);
		#endif
	}

	#if IS_FREE_RTOS
	// End of critical section.
	portEXIT_CRITICAL(&mux);

	#elif HAS_ATOMIC_BLOCK
	}

	#else
	// Enable interrupts again.
	interrupts();
	#endif

	// Replicate the most significant bit to pad out a 32-bit signed integer
	if (data[2] & 0x80) {
		filler = 0xFF;
	} else {
		filler = 0x00;
	}

	// Construct a 32-bit signed integer
	value = ( static_cast<unsigned long>(filler) << 24
			| static_cast<unsigned long>(data[2]) << 16
			| static_cast<unsigned long>(data[1]) << 8
			| static_cast<unsigned long>(data[0]) );

	return static_cast<long>(value);
}

void HX711::wait_ready(unsigned long delay_ms) {
	// Wait for the chip to become ready.
	// This is a blocking implementation and will
	// halt the sketch until a load cell is connected.
	while (!is_ready()) {
		// Probably will do no harm on AVR but will feed the Watchdog Timer (WDT) on ESP.
		// https://github.com/bogde/HX711/issues/73
		delay(delay_ms);
	}
}

bool HX711::wait_ready_retry(int retries, unsigned long delay_ms) {
	// Wait for the chip to become ready by
	// retrying for a specified amount of attempts.
	// https://github.com/bogde/HX711/issues/76
	int count = 0;
	while (count < retries) {
		if (is_ready()) {
			return true;
		}
		delay(delay_ms);
		count++;
	}
	return false;
}

bool HX711::wait_ready_timeout(unsigned long timeout, unsigned long delay_ms) {
	// Wait for the chip to become ready until timeout.
	// https://github.com/bogde/HX711/pull/96
	unsigned long millisStarted = millis();
	while (millis() - millisStarted < timeout) {
		if (is_ready()) {
			return true;
		}
		delay(delay_ms);
	}
	return false;
}

long HX711::read_average(byte times) {
	long sum = 0;
	for (byte i = 0; i < times; i++) {
		sum += read();
		// Probably will do no harm on AVR but will feed the Watchdog Timer (WDT) on ESP.
		// https://github.com/bogde/HX711/issues/73
		delay(0);
	}
	return sum / times;
}

double HX711::get_value(byte times) {
	return read_average(times) - OFFSET;
}

float HX711::get_units(byte times) {
	return get_value(times) / SCALE;
}

void HX711::tare(byte times) {
	double sum = read_average(times);
	set_offset(sum);
}

void HX711::set_scale(float scale) {
	SCALE = scale;
}

float HX711::get_scale() {
	return SCALE;
}

void HX711::set_offset(long offset) {
	OFFSET = offset;
}

long HX711::get_offset() {
	return OFFSET;
}

void HX711::power_down() {
	digitalWrite(PD_SCK, LOW);
	digitalWrite(PD_SCK, HIGH);
}

void HX711::power_up() {
	digitalWrite(PD_SCK, LOW);
}
//=== END : /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/HX711.ino

//=== START : /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Inner_FSMs.ino
#line 1 "/Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Inner_FSMs.ino"
#include "Accelerometer_functions.h";
#include "Thresholds.h"
#include "Motor_functions.h"
#include "Encoder_functions.h"
#include "Inner_FSMs.h"
#include "LoadCell_functions.h"

/**
 * Function to monitor speed of Stand to Sit motion
 */
void Sit() {
  if (getX() > SIT_X_TH_POS) {
    curr_speed++;
    rotate(MTR_BACKWARD, RET_ANG);
  } else if (getX() < SIT_X_TH_NEG) {
    curr_speed--;
    rotate(MTR_BACKWARD, RET_ANG);
  }
}

/**
 * Function to monitor speed of Sit to Stand motion
 */
void Stand() {
    if (getX() > STAND_X_TH_POS) {
    curr_speed++;
    rotate(MTR_FORWARD, EXT_ANG);
  } else if (getX() < STAND_X_TH_NEG) {
    curr_speed--;
    rotate(MTR_FORWARD, EXT_ANG);
  }
}


void Free_Swing() {
  // Need to figure out how to get g_ang instead of using EXT_ANG and RET_ANG to be able to better control speed through rotate function
  // either use getX and getY or somehow figure out how to use transient rotation from accelerometer
  int g_ang = encKnee + acc_to_ang(getX());
  if (abs(getX() + getY()) > G_TH) {
    if (getY() > G_TH_MAX || getY() < G_TH_MIN) {
      if (getX() < FS_X_TH_NEG) {
        rotate(MTR_FORWARD, g_ang);
      } else {
        rotate(MTR_BACKWARD, g_ang);
      }
    } else {
      analogWrite(PWM, 0);
      curr_speed = 0;
    }
  } else {
    analogWrite(PWM, 0);
    curr_speed = 0;
  }
}

int GaitFSM(GaitFSMState init_state) {
  gait_curr_state = init_state;
  switch(gait_curr_state) {
    case HEEL_OFF:
      // Bend_Knee();
      if (lcFront <= GAIT_HEEL_OFF_SWING_RET_TH ) {
        gait_curr_state = SWING_RET;
      }
      return 1;
    case SWING_RET:
      // Retract_Knee();
      // if (yAcc == ankles_aligned_threshold) {
        gait_curr_state = SWING_EXT;
      return 1;
    case SWING_EXT:
      // Extend_Knee();
      if (lcBack > GAIT_SWING_EXT_END_TH) {
        gait_curr_state = HEEL_OFF; // set it back to the first state for the next run of the Gait FSM
      }
      return 0;
    default:
      return 1;
  }
}

// --------------------------------------------------------------------------------------------------------------

void Bend_Knee() {
  
}

void Retract_Knee() {
  
}

void Extend_Knee() {
  
}

//=== END : /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Inner_FSMs.ino

//=== START : /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/LoadCell_functions.ino
#line 1 "/Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/LoadCell_functions.ino"
#include "LoadCell_functions.h"
#include "SPI.h"

/**
 * Initialization of all loadcells
 */
void Init_LC() {
  loadcell1.begin(LOADCELL_DOUT_PIN1, LOADCELL_SCK_PIN);
  loadcell1.set_scale(LOADCELL_DIVIDER);
  loadcell1.set_offset(LOADCELL_OFFSET);
  loadcell1.set_gain();
//  loadcell2.begin(LOADCELL_DOUT_PIN2, LOADCELL_SCK_PIN);
//  loadcell2.set_scale(LOADCELL_DIVIDER);
//  loadcell2.set_offset(LOADCELL_OFFSET);
//  loadcell2.set_gain();
//  loadcell3.begin(LOADCELL_DOUT_PIN3, LOADCELL_SCK_PIN);
//  loadcell3.set_scale(LOADCELL_DIVIDER);
//  loadcell3.set_offset(LOADCELL_OFFSET);
//  loadcell3.set_gain();
//  loadcell4.begin(LOADCELL_DOUT_PIN4, LOADCELL_SCK_PIN);
//  loadcell4.set_scale(LOADCELL_DIVIDER);
//  loadcell4.set_offset(LOADCELL_OFFSET);
//  loadcell4.set_gain();
  
}

/**
 * Used for calibration of the loadcells
 * Uses the computer to adjust the variables for the loadcells
 * 
 * NOTE: This may need to change (particularly the use of separate LOADCELL_DIVIDER variables
 * for each loadcell since each loadcell may be different
 * NOTE: The use of the zero factor may be useful for an offset for each loadcell
 */
void Calibrate_LC(HX711 loadcell) {
  Serial.println("Make sure Arduino is attached to laptop for calibration");
  Serial.println("Calibrating Loadcell 1: ");

  Serial.println("HX711 calibration sketch");
  Serial.println("Remove all weight from scale");
  Serial.println("After readings begin, place known weight on scale");
  Serial.println("Press + or a to increase calibration factor");
  Serial.println("Press - or z to decrease calibration factor");

  loadcell.set_scale();
  loadcell.tare(); //Reset the scale to 0

  long zero_factor = loadcell.read_average(); //Get a baseline reading
  Serial.print("Zero factor: "); //This can be used to remove the need to tare the scale. Useful in permanent scale projects.
  Serial.println(zero_factor);

  float calibration_factor = LOADCELL_DIVIDER;
  while(1) {
    loadcell.set_scale(calibration_factor); //Adjust to this calibration factor

    Serial.print("Reading: ");
    Serial.print(loadcell.get_units(), 1);
    Serial.print(" lbs"); //Change this to kg and re-adjust the calibration factor if you follow SI units like a sane person
    Serial.print(" calibration_factor: ");
    Serial.print(calibration_factor);
    Serial.println();
  
    if(Serial.available())
    {
      char temp = Serial.read();
      if(temp == '+' || temp == 'a')
        calibration_factor += 10;
      else if(temp == '-' || temp == 'z')
        calibration_factor -= 10;
      else if(temp == '0')
        break;
    }
  }
  
}

/**
 * Reads loadcell 1 (front) and updates global variable
 */
int Read_LC1() {
  return loadcell1.read();
}

/**
 * Reads loadcell 2 (back) and updates global variable
 */
int Read_LC2() {
  return loadcell1.read();
}

/**
 * Reads loadcell 3 (left) and updates global variable
 */
int Read_LC3() {
  return loadcell1.read();
}

/**
 * Reads loadcell 4 (right) and updates global variable
 */
int Read_LC4() {
  return loadcell1.read();
}

//=== END : /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/LoadCell_functions.ino

//=== START : /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Motor_functions.ino
#line 1 "/Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Motor_functions.ino"
#include <Arduino.h>
#include "Motor_functions.h"
#include "Encoder_functions.h"

/**
 * Initializes motor
 */
void Init_Motors()
{
  pinMode(PWM, OUTPUT);
  pinMode(DIR, OUTPUT);  
  analogWrite(PWM,0);
  digitalWrite(DIR,HIGH);
}

/**
 * rotate is the base function for turning the motor
 * @param dir - is the direction of that the motor spins
 * @param angle - is the destination angle at the end of the rotation
 * @return the current angle
 */
int rotate(int dir, int angle) {
  digitalWrite(DIR, dir);
  curr_ang = encKnee;
  int threshold_range = dir == MTR_FORWARD ? angle + RANGE_SLOW : angle - RANGE_SLOW; // This may change depending on direction of spinning
  if (curr_speed < MAX_MPWR && curr_ang > threshold_range) {
    // speed motor up - need more effective implementation here (same for slowing down)
    curr_speed++;
  } else if (curr_ang < threshold_range && curr_speed != 0) {
    curr_speed--;
  }
  if (curr_ang < angle + RANGE_STOP && curr_ang > angle - RANGE_STOP) { // range of error allowed
    curr_speed = 0;
    analogWrite(PWM, curr_speed);
  } else {
    analogWrite(PWM, curr_speed);
  }
}

int rot(int angle) {
  int vel = MAX_MPWR;
  int slowVel = MAX_MPWR / 2;

  if (encKnee < (angle - RANGE_STOP)) {
    digitalWrite(DIR, MTR_BACKWARD);
    if ((angle - encKnee) < RANGE_SLOW)
      curr_speed = slowVel;
    else curr_speed = MAX_MPWR;
  }
  else if (encKnee > (angle + RANGE_STOP)) {
    digitalWrite(DIR, MTR_FORWARD);
    if ((encKnee - angle) < RANGE_SLOW)
      curr_speed = slowVel;
    else curr_speed = MAX_MPWR;
  }
  else curr_speed = MIN_MPWR;

  analogWrite(PWM, curr_speed);  
}

// we are assuming high for dir is clockwise
///**
// * @param halt is the stopping position
// * @param is the max speed
// * @param dir is the direction
// * @return the current position
// */
//uint16_t rotate(uint16_t halt, uint8_t pwm, uint8_t dir)
//{
//  int curr_pos = getPositionSPI(ENC_0, RES14);
//  int change_dist = dir ? halt - curr_pos : MAX_DIST - (halt - curr_pos);
//  int init_dist = change_dist;
//
//  while (abs(change_dist) > STOP_DIST)
//  {
//    // calculate speed ratio (ramps up and down; fastest at half the distance travelled)
//    int curr_speed = 1 - abs(change_dist - init_dist / 2);
//    int speedM = curr_speed * MOTOR_PWR + MIN_MPWR;
//    // write to the motor to go the desired speed in the desired direction
//    digitalWrite(DIR, dir);
//    analogWrite(PWM, speedM);
//
//    // get new current position
//    curr_pos = getPositionSPI(ENC_0, RES14);
//    change_dist = dir ? halt - curr_pos : MAX_DIST - (halt - curr_pos);
//  }
//  return curr_pos;
//}

//uint16_t stall(uint8_t pwm, uint8_t dir)
//{
//  return 0;
//}

//=== END : /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Motor_functions.ino

//=== START : /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Sensor_Interrupt.ino
#line 1 "/Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Sensor_Interrupt.ino"
#include <TimerOne.h>
#include "Sensor_Interrupt.h"
#include "Encoder_functions.h"
#include "Motor_functions.h"
#include "FSM.h"

/**
 * Initializes Interrupt
 */
void Init_Interrupt() {
//  //set timer1 interrupt at 20Hz
//  TCCR1A = 0;// set entire TCCR0A register to 0
//  TCCR1B = 0x0C;// set WGM12 to CTC mode and set prescale to 256
//  TCNT1  = 0;//initialize counter value to 0
//  // set compare match register for about 20hz increments
//  OCR1A = 3124;// = (16*10^6) / (20*4096) - 1 (must be <256) 
//  // enable timer compare interrupt
//  TIMSK1 |= (1 << OCIE1A);

  Timer1.initialize(50000);
  Timer1.attachInterrupt(Read_Sensors, 50000);
}

/**
 * Function to update sensor global variables
 */
void Read_Sensors() {
  encKnee = bitToDegrees(getPositionSPI(ENC_0, RES14));
//  encCAM = bitToDegrees(getPositionSPI(ENC_1, RES14));
//  lcFront = Read_LC1();
//  lcBack = Read_LC2();
//  lcLeft = Read_LC3();
//  lcRight = Read_LC4();
  if (encKnee == RET_ANG) {
    fully_retracted = true;
    fully_extended = false;
    retracted = true;
  } else if (encKnee == EXT_ANG) {
    fully_extended = true;
    fully_retracted = false;
  } else {
    fully_extended = false;
    fully_retracted = false;
  }
}

/**
 * Interrupt function
 */
//ISR(__vectorTIMER_COMPA_vect) {
//  Serial.println("Interrupt");
//  Read_Sensors();
//}

//=== END : /Users/ramsothman/Documents/Backup/cybathlonTest/Master Sketch Test/MasterTest/Sensor_Interrupt.ino
